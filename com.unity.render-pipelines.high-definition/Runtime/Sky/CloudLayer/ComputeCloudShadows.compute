#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma multi_compile_local _ USE_CLOUD_MAP
#pragma multi_compile_local _ USE_CLOUD_MOTION

#pragma kernel ComputeCloudShadows KERNEL_NAME=ComputeCloudShadows

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/CloudLayer/CloudLayer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

RW_TEXTURE2D(float, _CloudShadowsOutput);

static const int res = 256;
static float3 tangent;
static float3 bitangent;

float BoxWeight( in float2 p )
{
    p = abs(p);
    return 1.0 - max(p.x, p.y);
}

// uv is in [-1, 1]
float ComputeCloudShadow(float2 uv, out float weight)
{
    weight = saturate(BoxWeight(uv) * 2.0);

    const float width = 0.1;
    float3 dir = -_SunDirection + uv.x * width * tangent + uv.y * width * bitangent;

    float shadow = GetCloudOpacity(dir);
    return Smootherstep01(shadow * weight);
}

[numthreads(8, 8, 1)]
void KERNEL_NAME(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    tangent = normalize(cross(-_SunDirection, float3(0.0, 1.0, 0.0)));
    bitangent = cross(tangent, -_SunDirection);

    float2 uv = float2(dispatchThreadId.x / (float)res, dispatchThreadId.y / (float)res) * 2.0 - 1.0;
    
    float weight1, weight2;
    float shadow1 = ComputeCloudShadow(uv, weight1);

    uv *= 2.0;
    uv -= (abs(uv) > 1.0) * sign(uv) * 2.0;

    float shadow2 = ComputeCloudShadow(uv, weight2);
    shadow2 = shadow2 / max(weight2, 0.001) * (1.0 - weight1);

    _CloudShadowsOutput[dispatchThreadId] = (shadow1+shadow2);// / min(weight1 + weight2, 0.001);
}
